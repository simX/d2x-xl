/*nTHE COMPUTER CODE CONTAINED HEREIN IS THE SOLE PROPERTY OF PARALLAXnSOFTWARE CORPORATION ("PARALLAX").  PARALLAX, IN DISTRIBUTING THE CODE TOnEND-USERS, AND SUBJECT TO ALL OF THE TERMS AND CONDITIONS HEREIN, GRANTS AnROYALTY-FREE, PERPETUAL LICENSE TO SUCH END-USERS FOR USE BY SUCH END-USERSnIN USING, DISPLAYING,  AND CREATING DERIVATIVE WORKS THEREOF, SO LONG ASnSUCH USE, DISPLAY OR CREATION IS FOR NON-COMMERCIAL, ROYALTY OR REVENUEnFREE PURPOSES.  IN NO EVENT SHALL THE END-USER USE THE COMPUTER CODEnCONTAINED HEREIN FOR REVENUE-BEARING PURPOSES.  THE END-USER UNDERSTANDSnAND AGREES TO THE TERMS HEREIN AND ACCEPTS THE SAME BY USE OF THIS FILE.nCOPYRIGHT 1993-1999 PARALLAX SOFTWARE CORPORATION.  ALL RIGHTS RESERVED.n*/nn#ifdef HAVE_CONFIG_Hn#include <conf.h>n#endifnn#include <string.h>	// for memsetn#include <stdio.h>n#include <time.h>n#include <math.h>nn#include "inferno.h"n#include "newdemo.h"n#include "network.h"n#include "interp.h"n#include "ogl_lib.h"n#include "render.h"n#include "transprender.h"n#include "glare.h"n#include "sphere.h"n#include "marker.h"n#include "fireball.h"n#include "objsmoke.h"n#include "objrender.h"n#include "objeffects.h"n#include "hiresmodels.h"nn#ifndef fabsfn#	define fabsf(_f)	(float) fabs (_f)n#endifnn#define IS_TRACK_GOAL(_objP)	(((_objP) == gameData.objs.trackGoals [0]) || ((_objP) == gameData.objs.trackGoals [1]))nn// -----------------------------------------------------------------------------nnvoid RenderObjectHalo (vmsVector *vPos, fix xSize, float red, float green, float blue, float alpha, int bCorona)n{nif ((gameOpts->render.coronas.bShots && (bCorona ? LoadCorona () : LoadHalo ()))) {n	tRgbaColorf	c = {red, green, blue, alpha};n	glDepthMask (0);n	G3DrawSprite(*vPos, xSize, xSize, bCorona ? bmpCorona : bmpHalo, &c, alpha * 4.0f / 3.0f, 1, 1);n	glDepthMask (1);n	}n}nn// -----------------------------------------------------------------------------nnvoid RenderPowerupCorona (tObject *objP, float red, float green, float blue, float alpha)n{n	int	bAdditive = gameOpts->render.coronas.bAdditiveObjs;nnif ((IsEnergyPowerup (objP->info.nId) ? gameOpts->render.coronas.bPowerups : gameOpts->render.coronas.bWeapons) &&n	 (bAdditive ? LoadGlare () : LoadCorona ())) {n	static tRgbaColorf keyColors [3] = {n		{0.2f, 0.2f, 0.9f, 0.2f},n		{0.9f, 0.2f, 0.2f, 0.2f},n		{0.9f, 0.8f, 0.2f, 0.2f}n		};nn	tRgbaColorf color;n	fix			xSize;n	float			fScale;n	int			bDepthSort;n	grsBitmap	*bmP = bAdditive ? bmpGlare : bmpCorona;nnn	if ((objP->info.nId >= POW_KEY_BLUE) && (objP->info.nId <= POW_KEY_GOLD)) {n		int i = objP->info.nId - POW_KEY_BLUE;nn		color = keyColors [(((i < 0) || (i > 2)) ? 3 : i)];n		xSize = 12 * F1_0;n		}n	else {n		float b = (float) sqrt ((red * 3 + green * 5 + blue * 2) / 10);n		color.red = red / b;n		color.green = green / b;n		color.blue = blue / b;n		xSize = 8 * F1_0;n		}n	color.alpha = alpha;n	if (bAdditive) {n		fScale = coronaIntensities [gameOpts->render.coronas.nObjIntensity] / 2;n		color.red *= fScale;n		color.green *= fScale;n		color.blue *= fScale;n		}n	bDepthSort = gameOpts->render.bDepthSort;n	gameOpts->render.bDepthSort = -1;n	G3DrawSprite(objP->info.position.vPos, xSize, xSize, bmP, &color, alpha, gameOpts->render.coronas.bAdditiveObjs, 5);n	gameOpts->render.bDepthSort = bDepthSort;n	}n}nn//------------------------------------------------------------------------------nnvoid TransformHitboxf (tObject *objP, fVector *vertList, int iSubObj)n{nn	fVector		hv;n	tHitbox		*phb = gameData.models.hitboxes [objP->rType.polyObjInfo.nModel].hitboxes + iSubObj;n	vmsVector	vMin = phb->vMin;n	vmsVector	vMax = phb->vMax;n	int			i;nnfor (i = 0; i < 8; i++) {n	hv [X] = X2F (hitBoxOffsets [i][X] ? vMin [X] : vMax [X]);n	hv [Y] = X2F (hitBoxOffsets [i][Y] ? vMin [Y] : vMax [Y]);n	hv [Z] = X2F (hitBoxOffsets [i][Z] ? vMin [Z] : vMax [Z]);n	G3TransformPoint (vertList [i], hv, 0);n	}n}nn//------------------------------------------------------------------------------nn#if RENDER_HITBOXnnvoid RenderHitbox (tObject *objP, float red, float green, float blue, float alpha)n{n	fVector		vertList [8], v;n	tHitbox		*pmhb = gameData.models.hitboxes [objP->rType.polyObjInfo.nModel].hitboxes;n	tCloakInfo	ci = {0, GR_ACTUAL_FADE_LEVELS, 0, 0, 0, 0, 0};n	int			i, j, iBox, nBoxes, bHit = 0;n	float			fFade;nnif (!SHOW_OBJ_FX)n	return;nif (objP->info.nType == OBJ_PLAYER) {n	if (!EGI_FLAG (bPlayerShield, 0, 1, 0))n		return;n	if (gameData.multiplayer.players [objP->info.nId].flags & PLAYER_FLAGS_CLOAKED) {n		if (!GetCloakInfo (objP, 0, 0, &ci))n			return;n		fFade = (float) ci.nFadeValue / (float) GR_ACTUAL_FADE_LEVELS;n		red *= fFade;n		green *= fFade;n		blue *= fFade;n		}nn	}nelse if (objP->info.nType == OBJ_ROBOT) {n	if (!gameOpts->render.effects.bRobotShields)n		return;n	if (objP->cType.aiInfo.CLOAKED) {n		if (!GetCloakInfo (objP, 0, 0, &ci))n			return;n		fFade = (float) ci.nFadeValue / (float) GR_ACTUAL_FADE_LEVELS;n		red *= fFade;n		green *= fFade;n		blue *= fFade;n		}n	}nif (!EGI_FLAG (nHitboxes, 0, 0, 0)) {n	DrawShieldSphere (objP, red, green, blue, alpha);n	return;n	}nelse if (extraGameInfo [IsMultiGame].nHitboxes == 1) {n	iBox =n	nBoxes = 0;n	}nelse {n	iBox = 1;n	nBoxes = gameData.models.hitboxes [objP->rType.polyObjInfo.nModel].nHitboxes;n	}nglDepthFunc (GL_LEQUAL);nglEnable (GL_BLEND);nglBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);nglDisable (GL_TEXTURE_2D);nglDepthMask (0);nglColor4f (red, green, blue, alpha / 2);nG3StartInstanceMatrix(objP->info.position.vPos, objP->info.position.mOrient);nfor (; iBox <= nBoxes; iBox++) {n	if (iBox)n		G3StartInstanceAngles(pmhb [iBox].vOffset, &vmsAngVec::ZERO);n	TransformHitboxf (objP, vertList, iBox);n	glBegin (GL_QUADS);n	for (i = 0; i < 6; i++) {n		for (j = 0; j < 4; j++)n			glVertex3fv ((GLfloat *) (vertList + hitboxFaceVerts [i][j]));n		}n	glEnd ();n	glLineWidth (2);n	for (i = 0; i < 6; i++) {n		glBegin (GL_LINES);n		v.SetZero();n		for (j = 0; j < 4; j++) {n			glVertex3fv ((GLfloat *) (vertList + hitboxFaceVerts [i][j]));n			v += vertList [hitboxFaceVerts [i][j]];n			}n		glEnd ();n		}n	glLineWidth (1);n	if (iBox)n		G3DoneInstance ();n	}nG3DoneInstance ();nfloat r = X2F (VmVecDist (&pmhb->vMin, &pmhb->vMax) / 2);n#if 0//def _DEBUG	//display collision pointnif (gameStates.app.nSDLTicks - gameData.models.hitboxes [objP->rType.polyObjInfo.nModel].tHit < 500) {n	tObject	o;nn	o.position.vPos = gameData.models.hitboxes [objP->rType.polyObjInfo.nModel].vHit;n	o.position.mOrient = objP->info.position.mOrient;n	o.size = F1_0 * 2;n	//SetRenderView (0, NULL);n	DrawShieldSphere (&o, 1, 0, 0, 0.33f);n	}n#endifnglDepthMask (1);nglDepthFunc (GL_LESS);n}nn#endifnn// -----------------------------------------------------------------------------nnvoid RenderPlayerShield (tObject *objP)n{n	int			bStencil, dt = 0, i = objP->info.nId, nColor = 0;n	float			alpha, scale = 1;n	tCloakInfo	ci;nn	static tRgbaColorf shieldColors [3] = {{0, 0.5f, 1, 1}, {1, 0.5f, 0, 1}, {1, 0.8f, 0.6f, 1}};nnif (!SHOW_OBJ_FX)n	return;n#if SHADOWSnif (SHOW_SHADOWS &&n	 (FAST_SHADOWS ? (gameStates.render.nShadowPass != 1) : (gameStates.render.nShadowPass != 3)))n	return;n#endifnif (EGI_FLAG (bPlayerShield, 0, 1, 0)) {n	if (gameData.multiplayer.players [i].flags & PLAYER_FLAGS_CLOAKED) {n		if (!GetCloakInfo (objP, 0, 0, &ci))n			return;n		scale = (float) ci.nFadeValue / (float) GR_ACTUAL_FADE_LEVELS;n		scale *= scale;n		}n	bStencil = StencilOff ();n	UseSpherePulse (&gameData.render.shield, gameData.multiplayer.spherePulse + i);n	if (gameData.multiplayer.bWasHit [i]) {n		if (gameData.multiplayer.bWasHit [i] < 0) {n			gameData.multiplayer.bWasHit [i] = 1;n			gameData.multiplayer.nLastHitTime [i] = gameStates.app.nSDLTicks;n			SetSpherePulse (gameData.multiplayer.spherePulse + i, 0.1f, 0.5f);n			dt = 0;n			}n		else if ((dt = gameStates.app.nSDLTicks - gameData.multiplayer.nLastHitTime [i]) >= 300) {n			gameData.multiplayer.bWasHit [i] = 0;n			SetSpherePulse (gameData.multiplayer.spherePulse + i, 0.02f, 0.4f);n			}n		}n	if (gameOpts->render.effects.bOnlyShieldHits && !gameData.multiplayer.bWasHit [i])n		return;n	if (gameData.multiplayer.players [i].flags & PLAYER_FLAGS_INVULNERABLE)n		nColor = 2;n	else if (gameData.multiplayer.bWasHit [i])n		nColor = 1;n	elsen		nColor = 0;n	if (gameData.multiplayer.bWasHit [i]) {n		alpha = (gameOpts->render.effects.bOnlyShieldHits ? (float) cos (sqrt ((double) dt / 300.0) * Pi / 2) : 1);n		scale *= alpha;n		}n	else if (gameData.multiplayer.players [i].flags & PLAYER_FLAGS_INVULNERABLE)n		alpha = 1;n	else {n		alpha = X2F (gameData.multiplayer.players [i].shields) / 100.0f;n		scale *= alpha;n		if (gameData.multiplayer.spherePulse [i].fSpeed == 0.0f)n			SetSpherePulse (gameData.multiplayer.spherePulse + i, 0.02f, 0.5f);n		}n#if RENDER_HITBOXn	RenderHitbox (objP, shieldColors [nColor].red * scale, shieldColors [nColor].green * scale, shieldColors [nColor].blue * scale, alpha);n#elsen	DrawShieldSphere (objP, shieldColors [nColor].red * scale, shieldColors [nColor].green * scale, shieldColors [nColor].blue * scale, alpha);n#endifn	StencilOn (bStencil);n	}n}nn// -----------------------------------------------------------------------------nnvoid RenderRobotShield (tObject *objP)n{n	static tRgbaColorf shieldColors [3] = {{0.75f, 0, 0.75f, 1}, {0, 0.5f, 1},{1, 0.5f, 0, 1}};nn#if RENDER_HITBOXnRenderHitbox (objP, 0.5f, 0.0f, 0.6f, 0.4f);n#elsen	float			scale = 1;n	tCloakInfo	ci;n	fix			dt;nnif (!gameOpts->render.effects.bRobotShields)n	return;nif ((objP->info.nType == OBJ_ROBOT) && objP->cType.aiInfo.CLOAKED) {n	if (!GetCloakInfo (objP, 0, 0, &ci))n		return;n	scale = (float) ci.nFadeValue / (float) GR_ACTUAL_FADE_LEVELS;n	scale *= scale;n	}ndt = gameStates.app.nSDLTicks - gameData.objs.xTimeLastHit [OBJ_IDX (objP)];nif (dt < 300) {n	scale *= gameOpts->render.effects.bOnlyShieldHits ? (float) cos (sqrt ((double) dt / 300.0) * Pi / 2) : 1;n	DrawShieldSphere (objP, shieldColors [2].red * scale, shieldColors [2].green * scale, shieldColors [2].blue * scale, 0.5f * scale);n	}nelse if (!gameOpts->render.effects.bOnlyShieldHits) {n	if ((objP->info.nType != OBJ_ROBOT) || ROBOTINFO (objP->info.nId).companion)n		DrawShieldSphere (objP, 0.0f, 0.5f * scale, 1.0f * scale, ObjectDamage (objP) / 2 * scale);n	elsen		DrawShieldSphere (objP, 0.75f * scale, 0.0f, 0.75f * scale, ObjectDamage (objP) / 2 * scale);n	}n#endifn}nn// -----------------------------------------------------------------------------nnstatic inline tRgbColorf *ObjectFrameColor (tObject *objP, tRgbColorf *pc)n{n	static tRgbColorf	defaultColor = {0, 1.0f, 0};n	static tRgbColorf	botDefColor = {1.0f, 0, 0};n	static tRgbColorf	reactorDefColor = {0.5f, 0, 0.5f};n	static tRgbColorf	playerDefColors [] = {{0,1.0f,0},{0,0,1.0f},{1.0f,0,0}};nnif (pc)n	return pc;nif (objP) {n	if (objP->info.nType == OBJ_REACTOR)n		return &reactorDefColor;n	else if (objP->info.nType == OBJ_ROBOT) {n		if (!ROBOTINFO (objP->info.nId).companion)n			return &botDefColor;n		}n	else if (objP->info.nType == OBJ_PLAYER) {n		if (IsTeamGame)n			return playerDefColors + GetTeam (objP->info.nId) + 1;n		return playerDefColors;n		}n	}nreturn &defaultColor;n}nn// -----------------------------------------------------------------------------nnvoid RenderDamageIndicator (tObject *objP, tRgbColorf *pc)n{n	vmsVector	vPos;n	fVector		fPos, fVerts [4];n	float			r, r2, w;n	int			i, bStencil, bDrawArrays;nnif (!SHOW_OBJ_FX)n	return;nif ((gameData.demo.nState == ND_STATE_PLAYBACK) && gameOpts->demo.bOldFormat)n	return;n#if SHADOWSnif (SHOW_SHADOWS && (gameStates.render.nShadowPass != 1))n//	 (FAST_SHADOWS ? (gameStates.render.nShadowPass != 3) : (gameStates.render.nShadowPass != 1)))n	return;n#endifnif (EGI_FLAG (bDamageIndicators, 0, 1, 0) &&n	 (extraGameInfo [IsMultiGame].bTargetIndicators < 2)) {n	bStencil = StencilOff ();n	pc = ObjectFrameColor (objP, pc);n	PolyObjPos (objP, &vPos);n	fPos = vPos.ToFloat();n	G3TransformPoint (fPos, fPos, 0);n	r = X2F (objP->info.xSize);n	r2 = r / 10;n	r = r2 * 9;n	w = 2 * r;n	fPos [X] -= r;n	fPos [Y] += r;n	w *= ObjectDamage (objP);n	fVerts [0][X] = fVerts [3][X] = fPos [X];n	fVerts [1][X] = fVerts [2][X] = fPos [X] + w;n	fVerts [0][Y] = fVerts [1][Y] = fPos [Y];n	fVerts [2][Y] = fVerts [3][Y] = fPos [Y] - r2;n	fVerts [0][Z] = fVerts [1][Z] = fVerts [2][Z] = fVerts [3][Z] = fPos [Z];n	fVerts [0][W] = fVerts [1][W] = fVerts [2][W] = fVerts [3][W] = 1;n	glColor4f (pc->red, pc->green, pc->blue, 2.0f / 3.0f);n	glDisable (GL_TEXTURE_2D);n#if 1n	if ((bDrawArrays = G3EnableClientState (GL_VERTEX_ARRAY, GL_TEXTURE0))) {n		glVertexPointer (4, GL_FLOAT, 0, fVerts);n		glDrawArrays (GL_QUADS, 0, 4);n		}n	else {n		glBegin (GL_QUADS);n		for (i = 0; i < 4; i++)n			glVertex3fv ((GLfloat *) (fVerts + i));n		glEnd ();n		}n#elsen	bDrawArrays = 0;n	glBegin (GL_QUADS);n	glVertex3f (fPos [X], fPos [Y], fPos [Z]);n	glVertex3f (fPos [X] + w, fPos [Y], fPos [Z]);n	glVertex3f (fPos [X] + w, fPos [Y] - r2, fPos [Z]);n	glVertex3f (fPos [X], fPos [Y] - r2, fPos [Z]);n	glEnd ();n#endifn	w = 2 * r;n	fVerts [1][X] = fVerts [2][X] = fPos [X] + w;n	glColor3fv ((GLfloat *) pc);n	if (bDrawArrays) {n		glVertexPointer (4, GL_FLOAT, 0, fVerts);n		glDrawArrays (GL_LINE_LOOP, 0, 4);n		glDisableClientState (GL_VERTEX_ARRAY);n		}n	else {n		glBegin (GL_LINE_LOOP);n		for (i = 0; i < 4; i++)n			glVertex3fv ((GLfloat *) (fVerts + i));n		glEnd ();n		}n	StencilOn (bStencil);n	}n}nn// -----------------------------------------------------------------------------nnstatic tRgbaColorf	trackGoalColor [2] = {{1, 0.5f, 0, 0.8f}, {1, 0.5f, 0, 0.8f}};nstatic int				nMslLockColor [2] = {0, 0};nstatic int				nMslLockColorIncr [2] = {-1, -1};nstatic float			fMslLockGreen [2] = {0.65f, 0.0f};nnvoid RenderMslLockIndicator (tObject *objP)n{n	#define INDICATOR_POSITIONS	60nn	static tSinCosf	sinCosInd [INDICATOR_POSITIONS];n	static int			bInitSinCos = 1;n	static int			nMslLockIndPos [2] = {0, 0};n	static int			t0 [2] = {0, 0}, tDelay [2] = {25, 40};nn	vmsVector			vPos;n	fVector				fPos, fVerts [3];n	float					r, r2;n	int					nTgtInd, bHasDmg, bVertexArrays, bMarker = (objP->info.nType == OBJ_MARKER);nnif (bMarker) {n	if (objP != SpawnMarkerObject (-1))n		return;n	}nelse {n	if (!EGI_FLAG (bMslLockIndicators, 0, 1, 0))n		return;n	if (!IS_TRACK_GOAL (objP))n		return;n	}nif (gameStates.app.nSDLTicks - t0 [bMarker] > tDelay [bMarker]) {n	t0 [bMarker] = gameStates.app.nSDLTicks;n	if (!nMslLockColor [bMarker] || (nMslLockColor [bMarker] == 15))n		nMslLockColorIncr [bMarker] = -nMslLockColorIncr [bMarker];n	nMslLockColor [bMarker] += nMslLockColorIncr [bMarker];n	trackGoalColor [bMarker].green = fMslLockGreen [bMarker] + (float) nMslLockColor [bMarker] / 100.0f;n	nMslLockIndPos [bMarker] = (nMslLockIndPos [bMarker] + 1) % INDICATOR_POSITIONS;n	}nPolyObjPos (objP, &vPos);nfPos = vPos.ToFloat();nG3TransformPoint (fPos, fPos, 0);nr = X2F (objP->info.xSize);nif (bMarker)n	r = 17 * r / 12;nr2 = r / 4;nnglDisable (GL_CULL_FACE);nG3DisableClientStates (1, 1, 1, GL_TEXTURE0);nbVertexArrays = G3EnableClientState (GL_VERTEX_ARRAY, GL_TEXTURE0);nglActiveTexture (GL_TEXTURE0);nglDisable (GL_TEXTURE_2D);nglColor4fv ((GLfloat *) (trackGoalColor + bMarker));nif (bMarker || gameOpts->render.cockpit.bRotateMslLockInd) {n	fVector	rotVerts [3];n	fMatrix	mRot;n	int		h, i, j;nn	if (bInitSinCos) {n		OglComputeSinCos (sizeofa (sinCosInd), sinCosInd);n		bInitSinCos = 0;n		}n	mRot [RVEC][X] =n	mRot [UVEC][Y] = sinCosInd [nMslLockIndPos [bMarker]].fCos;n	mRot [UVEC][X] = sinCosInd [nMslLockIndPos [bMarker]].fSin;n	mRot [RVEC][Y] = -mRot [UVEC][X];n	mRot [RVEC][Z] =n	mRot [UVEC][Z] =n	mRot [FVEC][X] =n	mRot [FVEC][Y] = 0;n	mRot [FVEC][Z] = 1;nn	fVerts [0][Z] =n	fVerts [1][Z] =n	fVerts [2][Z] = 0;n	rotVerts [0][W] =n	rotVerts [1][W] =n	rotVerts [2][W] = 0;n	fVerts [0][X] = -r2;n	fVerts [1][X] = +r2;n	fVerts [2][X] = 0;n	fVerts [0][Y] =n	fVerts [1][Y] = +r;n	fVerts [2][Y] = +r - r2;n	if (bVertexArrays)n		glVertexPointer (3, GL_FLOAT, sizeof (fVector), rotVerts);n	for (j = 0; j < 4; j++) {n		for (i = 0; i < 3; i++) {n			rotVerts [i] = mRot * fVerts [i];n			fVerts [i] = rotVerts [i];n			rotVerts [i] += fPos;n			}n		if (bMarker)n			glLineWidth (2);n		if (bVertexArrays)n			glDrawArrays (bMarker ? GL_LINE_LOOP : GL_TRIANGLES, 0, 3);n		else {n			glBegin (bMarker ? GL_LINE_LOOP : GL_TRIANGLES);n			for (h = 0; h < 3; h++)n				glVertex3fv ((GLfloat *) (rotVerts + h));n			glEnd ();n			}n		if (bMarker)n			glLineWidth (1);n		if (!j) {	//now rotate by 90 degreesn			mRot [RVEC][X] =n			mRot [UVEC][Y] = 0;n			mRot [UVEC][X] = 1;n			mRot [RVEC][Y] = -1;n			}n		}n	}nelse {n	fVerts [0][Z] =n	fVerts [1][Z] =n	fVerts [2][Z] = fPos [Z];n	fVerts [0][W] =n	fVerts [1][W] =n	fVerts [2][W] = 1;n	fVerts [0][X] = fPos [X] - r2;n	fVerts [1][X] = fPos [X] + r2;n	fVerts [2][X] = fPos [X];n	glVertexPointer (4, GL_FLOAT, 0, fVerts);n	nTgtInd = extraGameInfo [IsMultiGame].bTargetIndicators;n	bHasDmg = !EGI_FLAG (bTagOnlyHitObjs, 0, 1, 0) | (ObjectDamage (objP) < 1);n	if (!nTgtInd ||n		 ((nTgtInd == 1) && (!EGI_FLAG (bDamageIndicators, 0, 1, 0) || !bHasDmg)) ||n		 ((nTgtInd == 2) && !bHasDmg)) {n		fVerts [0][Y] =n		fVerts [1][Y] = fPos [Y] + r;n		fVerts [2][Y] = fPos [Y] + r - r2;n		glDrawArrays (GL_TRIANGLES, 0, 3);n		}n	fVerts [0][Y] =n	fVerts [1][Y] = fPos [Y] - r;n	fVerts [2][Y] = fPos [Y] - r + r2;n	glDrawArrays (GL_TRIANGLES, 0, 3);n	fVerts [0][X] =n	fVerts [1][X] = fPos [X] + r;n	fVerts [2][X] = fPos [X] + r - r2;n	fVerts [0][Y] = fPos [Y] + r2;n	fVerts [1][Y] = fPos [Y] - r2;n	fVerts [2][Y] = fPos [Y];n	glDrawArrays (GL_TRIANGLES, 0, 3);n	fVerts [0][X] =n	fVerts [1][X] = fPos [X] - r;n	fVerts [2][X] = fPos [X] - r + r2;n	glDrawArrays (GL_TRIANGLES, 0, 3);n	}nglDisableClientState (GL_VERTEX_ARRAY);nglEnable (GL_CULL_FACE);n}nn// -----------------------------------------------------------------------------nnvoid RenderTargetIndicator (tObject *objP, tRgbColorf *pc)n{n	vmsVector	vPos;n	fVector		fPos, fVerts [4];n	float			r, r2, r3;n	int			i, bStencil, bDrawArrays, nPlayer = (objP->info.nType == OBJ_PLAYER) ? objP->info.nId : -1;nnif (!SHOW_OBJ_FX)n	return;n#if SHADOWSnif (SHOW_SHADOWS && (gameStates.render.nShadowPass != 1))n//	 (FAST_SHADOWS ? (gameStates.render.nShadowPass != 3) : (gameStates.render.nShadowPass != 1)))n	return;n#endifn#if 0nif (!CanSeeObject (OBJ_IDX (objP), 1))n	return;n#endifnif (!EGI_FLAG (bCloakedIndicators, 0, 1, 0)) {n	if (nPlayer >= 0) {n		if ((gameData.multiplayer.players [nPlayer].flags & PLAYER_FLAGS_CLOAKED) && !GetCloakInfo (objP, 0, 0, NULL))n			return;n		}n	else if (objP->info.nType == OBJ_ROBOT) {n		if (objP->cType.aiInfo.CLOAKED && !GetCloakInfo (objP, 0, 0, NULL))n			return;n		}n	}nif (IsTeamGame && EGI_FLAG (bFriendlyIndicators, 0, 1, 0)) {n	if (GetTeam (nPlayer) != GetTeam (gameData.multiplayer.nLocalPlayer)) {n		if (!(gameData.multiplayer.players [nPlayer].flags & PLAYER_FLAGS_FLAG))n			return;n		pc = ObjectFrameColor (NULL, NULL);n		}n	}nRenderMslLockIndicator (objP);nif (EGI_FLAG (bTagOnlyHitObjs, 0, 1, 0) && (ObjectDamage (objP) >= 1.0f))n	return;nif (EGI_FLAG (bTargetIndicators, 0, 1, 0)) {n	bStencil = StencilOff ();n	glDisable (GL_TEXTURE_2D);n	pc = (EGI_FLAG (bMslLockIndicators, 0, 1, 0) && IS_TRACK_GOAL (objP) &&n			!gameOpts->render.cockpit.bRotateMslLockInd && (extraGameInfo [IsMultiGame].bTargetIndicators != 1)) ?n		  (tRgbColorf *) &trackGoalColor [0] : ObjectFrameColor (objP, pc);n	PolyObjPos (objP, &vPos);n	fPos = vPos.ToFloat();n	G3TransformPoint (fPos, fPos, 0);n	r = X2F (objP->info.xSize);n	glColor3fv ((GLfloat *) pc);n	fVerts [0][W] = fVerts [1][W] = fVerts [2][W] = fVerts [3][W] = 1;n	glVertexPointer (4, GL_FLOAT, 0, fVerts);n	if (extraGameInfo [IsMultiGame].bTargetIndicators == 1) {	//square bracketsn		r2 = r * 2 / 3;n		fVerts [0][X] = fVerts [3][X] = fPos [X] - r2;n		fVerts [1][X] = fVerts [2][X] = fPos [X] - r;n		fVerts [0][Y] = fVerts [1][Y] = fPos [Y] - r;n		fVerts [2][Y] = fVerts [3][Y] = fPos [Y] + r;n		fVerts [0][Z] =n		fVerts [1][Z] =n		fVerts [2][Z] =n		fVerts [3][Z] = fPos [Z];n		if ((bDrawArrays = G3EnableClientState (GL_VERTEX_ARRAY, GL_TEXTURE0)))n			glDrawArrays (GL_LINE_STRIP, 0, 4);n		else {n			glBegin (GL_LINE_STRIP);n			for (i = 0; i < 4; i++)n				glVertex3fv ((GLfloat *) (fVerts + i));n			glEnd ();n			}n		fVerts [0][X] = fVerts [3][X] = fPos [X] + r2;n		fVerts [1][X] = fVerts [2][X] = fPos [X] + r;n		if (bDrawArrays) {n			glDrawArrays (GL_LINE_STRIP, 0, 4);n			glDisableClientState (GL_VERTEX_ARRAY);n			}n		else {n			glBegin (GL_LINE_STRIP);n			for (i = 0; i < 4; i++)n				glVertex3fv ((GLfloat *) (fVerts + i));n			glEnd ();n			}n		}n	else {	//trianglen		r2 = r / 3;n		fVerts [0][X] = fPos [X] - r2;n		fVerts [1][X] = fPos [X] + r2;n		fVerts [2][X] = fPos [X];n		fVerts [0][Y] = fVerts [1][Y] = fPos [Y] + r;n		fVerts [2][Y] = fPos [Y] + r - r2;n		fVerts [0][Z] =n		fVerts [1][Z] =n		fVerts [2][Z] = fPos [Z];n		if ((bDrawArrays = G3EnableClientState (GL_VERTEX_ARRAY, GL_TEXTURE0)))n			glDrawArrays (GL_LINE_LOOP, 0, 3);n		else {n			glBegin (GL_LINE_LOOP);n			glVertex3fv ((GLfloat *) fVerts);n			glVertex3fv ((GLfloat *) (fVerts + 1));n			glVertex3fv ((GLfloat *) (fVerts + 2));n			glEnd ();n			}n		if (EGI_FLAG (bDamageIndicators, 0, 1, 0)) {n			r3 = ObjectDamage (objP);n			if (r3 < 1.0f) {n				if (r3 < 0.0f)n					r3 = 0.0f;n				fVerts [0][X] = fPos [X] - r2 * r3;n				fVerts [1][X] = fPos [X] + r2 * r3;n				fVerts [2][X] = fPos [X];n				fVerts [0][Y] = fVerts [1][Y] = fPos [Y] + r - r2 * (1.0f - r3);n				//fVerts [2][Y] = fPos [Y] + r - r2;n				}n			}n		glColor4f (pc->red, pc->green, pc->blue, 2.0f / 3.0f);n		if (bDrawArrays) {n			glDrawArrays (GL_TRIANGLES, 0, 3);n			glDisableClientState (GL_VERTEX_ARRAY);n			}n		else {n			glBegin (GL_TRIANGLES);n			for (i = 0; i < 3; i++)n			glVertex3fv ((GLfloat *) (fVerts + i));n			glEnd ();n			}n		}n	StencilOn (bStencil);n	}nRenderDamageIndicator (objP, pc);n}nn// -----------------------------------------------------------------------------nnvoid RenderTowedFlag (tObject *objP)n{n	static fVector fVerts [4] = {n		fVector::Create(0.0f, 2.0f / 3.0f, 0.0f, 1.0f),n		fVector::Create(0.0f, 2.0f / 3.0f, -1.0f, 1.0f),n		fVector::Create(0.0f, -(1.0f / 3.0f), -1.0f, 1.0f),n		fVector::Create(0.0f, -(1.0f / 3.0f), 0.0f, 1.0f)n	};nn	static tTexCoord2f texCoordList [4] = {{{0.0f, -0.3f}}, {{1.0f, -0.3f}}, {{1.0f, 0.7f}}, {{0.0f, 0.7f}}};nnif (gameStates.app.bNostalgia)n	return;n#if SHADOWSnif (SHOW_SHADOWS && (gameStates.render.nShadowPass != 1))n//	 (FAST_SHADOWS ? (gameStates.render.nShadowPass != 3) : (gameStates.render.nShadowPass != 1)))n	return;n#endifnif (IsTeamGame && (gameData.multiplayer.players [objP->info.nId].flags & PLAYER_FLAGS_FLAG)) {n		vmsVector		vPos = objP->info.position.vPos;n		fVector			vPosf;n		tFlagData		*pf = gameData.pig.flags + !GetTeam (objP->info.nId);n		tPathPoint		*pp = GetPathPoint (&pf->path);n		int				i, bStencil;n		float				r;n		grsBitmap		*bmP;nn	if (pp) {n		bStencil = StencilOff ();n		OglActiveTexture (GL_TEXTURE0, 0);n		glEnable (GL_TEXTURE_2D);n		glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);n		PIGGY_PAGE_IN (pf->bmi.index, 0);n		bmP = gameData.pig.tex.pBitmaps + pf->vcP->frames [pf->vci.nCurFrame].index;n		if (OglBindBmTex (bmP, 1, 2))n			return;n		bmP = BmCurFrame (bmP, -1);n		OglTexWrap (bmP->glTexture, GL_REPEAT);n		vPos += objP->info.position.mOrient [FVEC] * (-objP->info.xSize);n		r = X2F (objP->info.xSize);n		G3StartInstanceMatrix (vPos, pp->mOrient);n		glBegin (GL_QUADS);n		glColor3f (1.0f, 1.0f, 1.0f);n		for (i = 0; i < 4; i++) {n			vPosf [X] = 0;n			vPosf [Y] = fVerts [i][Y] * r;n			vPosf [Z] = fVerts [i][Z] * r;n			G3TransformPoint (vPosf, vPosf, 0);n			glTexCoord2fv ((GLfloat *) (texCoordList + i));n			glVertex3fv ((GLfloat *) &vPosf);n			}n		for (i = 3; i >= 0; i--) {n			vPosf [X] = 0;n			vPosf [Y] = fVerts [i][Y] * r;n			vPosf [Z] = fVerts [i][Z] * r;n			G3TransformPoint (vPosf, vPosf, 0);n			glTexCoord2fv ((GLfloat *) (texCoordList + i));n			glVertex3fv ((GLfloat *) &vPosf);n			}n		glEnd ();n		G3DoneInstance ();n		OGL_BINDTEX (0);n		StencilOn (bStencil);n		}n	}n}nn// -----------------------------------------------------------------------------nn#define	RING_SIZE		16n#define	THRUSTER_SEGS	14nnstatic fVector	vFlame [THRUSTER_SEGS][RING_SIZE];nstatic int			bHaveFlame = 0;nnstatic fVector	vRing [RING_SIZE] = {n	fVector::Create(-0.5f, -0.5f, 0.0f, 1.0f),n	fVector::Create(-0.6533f, -0.2706f, 0.0f, 1.0f),n	fVector::Create(-0.7071f, 0.0f, 0.0f, 1.0f),n	fVector::Create(-0.6533f, 0.2706f, 0.0f, 1.0f),n	fVector::Create(-0.5f, 0.5f, 0.0f, 1.0f),n	fVector::Create(-0.2706f, 0.6533f, 0.0f, 1.0f),n	fVector::Create(0.0f, 0.7071f, 0.0f, 1.0f),n	fVector::Create(0.2706f, 0.6533f, 0.0f, 1.0f),n	fVector::Create(0.5f, 0.5f, 0.0f, 1.0f),n	fVector::Create(0.6533f, 0.2706f, 0.0f, 1.0f),n	fVector::Create(0.7071f, 0.0f, 0.0f, 1.0f),n	fVector::Create(0.6533f, -0.2706f, 0.0f, 1.0f),n	fVector::Create(0.5f, -0.5f, 0.0f, 1.0f),n	fVector::Create(0.2706f, -0.6533f, 0.0f, 1.0f),n	fVector::Create(0.0f, -0.7071f, 0.0f, 1.0f),n	fVector::Create(-0.2706f, -0.6533f, 0.0f, 1.0f)n};nnstatic int		nStripIdx [] = {0,15,1,14,2,13,3,12,4,11,5,10,6,9,7,8};nnvoid CreateThrusterFlame (void)n{nif (!bHaveFlame) {n		fVector		*pv;n		int			i, j, m, n;n		double		phi, sinPhi;n		float			z = 0,n						fScale = 2.0f / 3.0f,n						fStep [2] = {1.0f / 4.0f, 1.0f / 3.0f};nn	pv = &vFlame [0][0];n	for (i = 0, phi = 0; i < 5; i++, phi += Pi / 8, z -= fStep [0]) {n		sinPhi = (1 + sin (phi) / 2) * fScale;n		for (j = 0; j < RING_SIZE; j++, pv++) {n/*n			pv->x() = vRing [j][X] * (float) sinPhi;n			pv->y() = vRing [j][Y] * (float) sinPhi;n*/n			*pv = vRing [j] * (float)sinPhi;n			(*pv) [Z] = z;n			}n		}n	m = n = THRUSTER_SEGS - i + 1;n	for (phi = Pi / 2; i < THRUSTER_SEGS; i++, phi += Pi / 8, z -= fStep [1], m--) {n		sinPhi = (1 + sin (phi) / 2) * fScale * m / n;n		for (j = 0; j < RING_SIZE; j++, pv++) {n/*n			pv->x() = vRing [j][X] * (float) sinPhi;n			pv->y() = vRing [j][Y] * (float) sinPhi;n*/n			*pv = vRing [j] * (float)sinPhi;n			(*pv) [Z] = z;n			}n		}n	bHaveFlame = 1;n	}n}nn// -----------------------------------------------------------------------------nnvoid CalcShipThrusterPos (tObject *objP, vmsVector *vPos)n{n	tTransformation	*pPos = OBJPOS (objP);nnif (gameOpts->render.bHiresModels) {n	vPos [0] = pPos->vPos + pPos->mOrient [FVEC] * (-objP->info.xSize);n	vPos [0] += pPos->mOrient [RVEC] * (-(8 * objP->info.xSize / 44));n	vPos [1] = vPos [0] + pPos->mOrient [RVEC] * (8 * objP->info.xSize / 22);n	}nelse {n	vPos [0] = pPos->vPos + pPos->mOrient [FVEC] * (-objP->info.xSize / 10 * 9);n	if (gameStates.app.bFixModels)n		vPos [0] += pPos->mOrient [UVEC] * (objP->info.xSize / 40);n	elsen		vPos [0] += pPos->mOrient [UVEC] * (-objP->info.xSize / 20);n	vPos [1] = vPos [0];n	vPos [0] += pPos->mOrient [RVEC] * (-8 * objP->info.xSize / 49);n	vPos [1] += pPos->mOrient [RVEC] * (8 * objP->info.xSize / 49);n	}n}nn// -----------------------------------------------------------------------------nnint CalcThrusterPos (tObject *objP, tThrusterInfo *tiP, int bAfterburnerBlob)n{n	tThrusterInfo		ti;n	tThrusterData		*pt = NULL;n	int					i, nThrusters,n							bMissile = IS_MISSILE (objP),n							bSpectate = SPECTATOR (objP);nnti = *tiP;nti.pp = NULL;nti.mtP = gameData.models.thrusters + objP->rType.polyObjInfo.nModel;nnThrusters = ti.mtP->nCount;nif (gameOpts->render.bHiresModels && (objP->info.nType == OBJ_PLAYER) && !ASEModel (objP->rType.polyObjInfo.nModel)) {n	if (!bSpectate) {n		pt = gameData.render.thrusters + objP->info.nId;n		ti.pp = GetPathPoint (&pt->path);n		}n	ti.fSize = (ti.fLength + 1) / 2;n	nThrusters = 2;n	CalcShipThrusterPos (objP, ti.vPos);n	ti.mtP = NULL;n	}nelse if (bAfterburnerBlob || (bMissile && !nThrusters)) {n		tHitbox	*phb = gameData.models.hitboxes [objP->rType.polyObjInfo.nModel].hitboxes;n		fix		nObjRad = RENDERPATH ? (phb->vMax [Z] - phb->vMin [Z]) / 2 : 2 * (phb->vMax [Z] - phb->vMin [Z]) / 3;nn	if (bAfterburnerBlob)n		nObjRad *= 2;n	if (objP->info.nId == EARTHSHAKER_ID)n		ti.fSize = 1.0f;n	else if ((objP->info.nId == MEGAMSL_ID) || (objP->info.nId == EARTHSHAKER_MEGA_ID))n		ti.fSize = 0.8f;n	else if (objP->info.nId == SMARTMSL_ID)n		ti.fSize = 0.6f;n	elsen		ti.fSize = 0.5f;n	nThrusters = 1;n	if (EGI_FLAG (bThrusterFlames, 1, 1, 0) == 2)n		ti.fLength /= 2;n	if (gameData.models.nScale)n		ti.vPos [0] *= gameData.models.nScale;n	*ti.vPos = objP->info.position.vPos + objP->info.position.mOrient [FVEC] * (-nObjRad);n	ti.mtP = NULL;n	}nelse if ((objP->info.nType == OBJ_PLAYER) ||n			((objP->info.nType == OBJ_ROBOT) && !objP->cType.aiInfo.CLOAKED) ||n			bMissile) {n	vmsMatrix	m, *viewP;n	if (!bSpectate && (objP->info.nType == OBJ_PLAYER)) {n		pt = gameData.render.thrusters + objP->info.nId;n		ti.pp = GetPathPoint (&pt->path);n		}n	if (!nThrusters) {n		if (objP->info.nType != OBJ_PLAYER)n			return 0;n		if (!bSpectate) {n			pt = gameData.render.thrusters + objP->info.nId;n			ti.pp = GetPathPoint (&pt->path);n			}n		ti.fSize = (ti.fLength + 1) / 2;n		nThrusters = 2;n		CalcShipThrusterPos (objP, ti.vPos);n		}n	else {n		tTransformation *posP = OBJPOS (objP);n		if (SPECTATOR (objP)) {n			viewP = &m;n			m = posP->mOrient.Transpose();n		}n		elsen			viewP = ObjectView (objP);n		for (i = 0; i < nThrusters; i++) {n			ti.vPos [i] = *viewP * ti.mtP->vPos [i];n			if (gameData.models.nScale)n				ti.vPos [i] *= gameData.models.nScale;n			ti.vPos [i] += posP->vPos;n			ti.vDir [i] = *viewP * ti.mtP->vDir [i];n			}n		ti.fSize = ti.mtP->fSize;n		if (bMissile)n			nThrusters = 1;n		}n	}nelsen	return 0;n*tiP = ti;nreturn nThrusters;n}nn// -----------------------------------------------------------------------------nnvoid CreateLightTrail (vmsVector& vPos, vmsVector &vDir, float fSize, float fLength, grsBitmap *bmP, tRgbaColorf *colorP, bool bSprite)n{n	static tTexCoord2f	tcCorona [4] = {{{0,0}},{{1,0}},{{1,1}},{{0,1}}};n	static tTexCoord2f	tcTrail [3] = {{{0,0}},{{1,1}},{{1,0}}};n	static fVector	vEye = fVector::ZERO;nn	fVector	v, vPosf, vDirf, vNormf, vTrail [3], vCorona [4], fVecf;n	float		c = 1/*0.7f + 0.03f * fPulse*/, dotTrail, dotCorona;n	int		i;nnfVecf = vDir.ToFloat();nvPosf = vPos.ToFloat();nvTrail [2] = vPosf - fVecf * fLength;nG3TransformPoint (vTrail [2], vTrail [2], 0);nG3TransformPoint (vPosf, vPosf, 0);nvNormf = fVector::Normal (vTrail [2], vPosf, vEye);nvTrail [0] = vPosf + vNormf * fSize;nvTrail [1] = vPosf - vNormf * fSize;nvNormf = fVector::Normal (vTrail [0], vTrail [1], vTrail [2]);nif (bSprite) {n	vCorona [0] =n	vCorona [1] =n	vCorona [2] =n	vCorona [3] = vPosf;n	vCorona [0][X] = vPosf [X] - fSize;n	vCorona [2][X] = vPosf [X] - fSize;n	vCorona [1][X] = vPosf [X] + fSize;n	vCorona [2][X] = vPosf [X] + fSize;n	vCorona [0][Y] = vPosf [Y] - fSize;n	vCorona [1][Y] = vPosf [Y] - fSize;n	vCorona [2][Y] = vPosf [Y] + fSize;n	vCorona [3][Y] = vPosf [Y] + fSize;n	}nelse {n	vCorona [0] = vTrail [0];n	vCorona [2] = vTrail [1];n	vCorona [1] = vPosf + vNormf * fSize;n	vCorona [3] = vPosf + vNormf * (-fSize);n	}nfVector::Normalize (vPosf);nv = vTrail [2]; nfVector::Normalize (v);ndotTrail = fVector::Dot (vPosf, v);nv = *vCorona; nfVector::Normalize (v);ndotCorona = fVector::Dot (vPosf, v);nif (gameOpts->render.bDepthSort > 0)n	TIAddLightTrail (bmP, vCorona, tcCorona, (dotTrail < dotCorona) ? vTrail : NULL, tcTrail, colorP);nelse {n	glDisable (GL_CULL_FACE);n	glColor3f (c, c, c);n	if (dotTrail < dotCorona) {n		glBegin (GL_TRIANGLES);n		for (i = 0; i < 3; i++) {n			glTexCoord2fv ((GLfloat *) (tcTrail + i));n			glVertex3fv ((GLfloat *) (vTrail + i));n			}n		glEnd ();n		}n	glBegin (GL_QUADS);n	for (i = 0; i < 4; i++) {n		glTexCoord2fv ((GLfloat *) (tcCorona + i));n		glVertex3fv ((GLfloat *) (vCorona + i));n		}n	glEnd ();n	glEnable (GL_CULL_FACE);n	}n}nn// -----------------------------------------------------------------------------nnvoid RenderThrusterFlames (tObject *objP)n{n	int					h, i, j, k, l, nStyle, nThrusters, bStencil, bSpectate, bTextured;n	tRgbaColorf			c [2];n	tThrusterInfo		ti;n	fVector				v;n	float					fSpeed, fPulse, fFade [4];n	tThrusterData		*pt = NULL;nn	static time_t		tPulse = 0;n	static int			nPulse = 10;nnif (gameStates.app.bNostalgia)n	return;n#if SHADOWSnif (SHOW_SHADOWS && (gameStates.render.nShadowPass != 1))n//	 (FAST_SHADOWS ? (gameStates.render.nShadowPass != 3) : (gameStates.render.nShadowPass != 1)))n	return;n#endifn#if 1//ndef _DEBUGnif (!EGI_FLAG (bThrusterFlames, 1, 1, 0))n	return;n#endifnif ((objP->info.nType == OBJ_PLAYER) && (gameData.multiplayer.players [objP->info.nId].flags & PLAYER_FLAGS_CLOAKED))n	return;nfSpeed = X2F (objP->mType.physInfo.velocity.Mag());nti.fLength = fSpeed / 60.0f + 0.5f + (float) (rand () % 100) / 1000.0f;nif (!pt || (fSpeed >= pt->fSpeed)) {n	fFade [0] = 0.95f;n	fFade [1] = 0.85f;n	fFade [2] = 0.75f;n	fFade [3] = 0.65f;n	}nelse {n	fFade [0] = 0.9f;n	fFade [1] = 0.8f;n	fFade [2] = 0.7f;n	fFade [3] = 0.6f;n	}nif (pt)n	pt->fSpeed = fSpeed;nbSpectate = SPECTATOR (objP);nnif (gameStates.app.nSDLTicks - tPulse > 10) {n	tPulse = gameStates.app.nSDLTicks;n	nPulse = d_rand () % 11;n	}nfPulse = (float) nPulse / 10.0f;nti.pp = NULL;nnThrusters = CalcThrusterPos (objP, &ti, 0);nbStencil = StencilOff ();n//glDepthMask (0);nbTextured = 0;nnStyle = EGI_FLAG (bThrusterFlames, 1, 1, 0) == 2;nif (!LoadThruster ()) {n	extraGameInfo [IsMultiGame].bThrusterFlames = 2;n	glDisable (GL_TEXTURE_2D);n	}nelse if (gameOpts->render.bDepthSort <= 0) {n	glEnable (GL_TEXTURE_2D);n	if (OglBindBmTex (bmpThruster [nStyle], 1, -1)) {n		extraGameInfo [IsMultiGame].bThrusterFlames = 2;n		glDisable (GL_TEXTURE_2D);n		}n	else {n		OglTexWrap (bmpThruster [nStyle]->glTexture, GL_CLAMP);n		bTextured = 1;n		}n	}nif (nThrusters > 1) {n	vmsVector vRot [2];n	for (i = 0; i < 2; i++)n		G3RotatePoint(vRot [i], ti.vPos [i], 0);n	if (vRot [0][Z] < vRot [1][Z]) {n		vmsVector v = ti.vPos [0];n		ti.vPos [0] = ti.vPos [1];n		ti.vPos [1] = v;n		if (objP->info.nType == OBJ_ROBOT) {n			v = ti.vDir [0];n			ti.vDir [0] = ti.vDir [1];n			ti.vDir [1] = v;n			}n		}n	}nglEnable (GL_BLEND);nif (EGI_FLAG (bThrusterFlames, 1, 1, 0) == 1) {n		static tTexCoord2f	tcThruster [4] = {{{0,0}},{{1,0}},{{1,1}},{{0,1}}};n		static tTexCoord2f	tcFlame [3] = {{{0,0}},{{1,1}},{{1,0}}};n		static tRgbaColorf	tcColor = {0.75f, 0.75f, 0.75f, 1.0f};n		static fVector	vEye = fVector::ZERO;nn		fVector	vPosf, vNormf, vFlame [3], vThruster [4], fVecf;n		float		c = 1/*0.7f + 0.03f * fPulse*/, dotFlame, dotThruster;nn	if (gameData.models.nScale)n		ti.fSize *= X2F (gameData.models.nScale);n	ti.fLength *= 4 * ti.fSize;n	ti.fSize *= ((objP->info.nType == OBJ_PLAYER) && HaveHiresModel (objP->rType.polyObjInfo.nModel)) ? 1.2f : 1.5f;n#if 1n	if (!ti.mtP)n		fVecf = ti.pp ? ti.pp->mOrient [FVEC].ToFloat() : objP->info.position.mOrient [FVEC].ToFloat();n#endifn	for (h = 0; h < nThrusters; h++)n		CreateLightTrail (ti.vPos [h], ti.vDir [h], ti.fSize, ti.fLength, bmpThruster [nStyle], &tcColor, false);n	}nelse {n	tTexCoord3f	tTexCoord2fl, tTexCoord2flStep;nn	CreateThrusterFlame ();n	glLineWidth (3);n	OglCullFace (1);n	tTexCoord2flStep.v.u = 1.0f / RING_SIZE;n	tTexCoord2flStep.v.v = 0.5f / THRUSTER_SEGS;n	for (h = 0; h < nThrusters; h++) {n		if (bTextured) {n			float c = 1; //0.8f + 0.02f * fPulse;n			glColor3f (c, c, c); //, 0.9f);n			}n		elsen			{n			c [1].red = 0.5f + 0.05f * fPulse;n			c [1].green = 0.45f + 0.045f * fPulse;n			c [1].blue = 0.0f;n			c [1].alpha = 0.9f;n			}n		G3StartInstanceMatrix (ti.vPos [h], (ti.pp && !bSpectate) ? ti.pp->mOrient : objP->info.position.mOrient);n		for (i = 0; i < THRUSTER_SEGS - 1; i++) {n#if 1n			if (!bTextured) {n				c [0] = c [1];n				c [1].red *= 0.975f;n				c [1].green *= 0.8f;n				c [1].alpha *= fFade [i / 4];n				}n			glBegin (GL_QUAD_STRIP);n			for (j = 0; j < RING_SIZE + 1; j++) {n				k = j % RING_SIZE;n				tTexCoord2fl.v.u = j * tTexCoord2flStep.v.u;n				for (l = 0; l < 2; l++) {n					v = vFlame [i + l][k];n					v [X] *= ti.fSize;n					v [Y] *= ti.fSize;n					v [Z] *= ti.fLength;n					G3TransformPoint(v, v, 0);n					if (bTextured) {n						tTexCoord2fl.v.v = 0.25f + tTexCoord2flStep.v.v * (i + l);n						glTexCoord2fv ((GLfloat *) &tTexCoord2fl);n						}n					elsen						glColor4fv ((GLfloat *) (c + l)); // (c [l].red, c [l].green, c [l].blue, c [l].alpha);n					glVertex3fv ((GLfloat *) &v);n					}n				}n			glEnd ();n#elsen			glBegin (GL_LINE_LOOP);n			glColor4f (c [1].red, c [1].green, c [1].blue, c [1].alpha);n			for (j = 0; j < RING_SIZE; j++) {n				G3TransformPoint (&v, vFlame [i] + j);n				glVertex3fv ((GLfloat *) &v);n				}n			glEnd ();n#endifn			}n		glBegin (GL_TRIANGLE_STRIP);n		for (j = 0; j < RING_SIZE; j++) {n			G3TransformPoint(v, vFlame [0][nStripIdx [j]], 0);n			glVertex3fv ((GLfloat *) &v);n			}n		glEnd ();n		G3DoneInstance ();n		}n	glLineWidth (1);n	OglCullFace (0);n	}nglDepthMask (1);nStencilOn (bStencil);n}nn// -----------------------------------------------------------------------------nnvoid RenderLaserCorona (tObject *objP, tRgbaColorf *colorP, float alpha, float fScale)n{n	int	bAdditive = 1; //gameOpts->render.bAdditivenif (!SHOW_OBJ_FX)n	return;n#if SHADOWSnif (SHOW_SHADOWS && (gameStates.render.nShadowPass != 1))n//	 (FAST_SHADOWS ? (gameStates.render.nShadowPass != 3) : (gameStates.render.nShadowPass != 1)))n	return;n#endifnif (gameOpts->render.coronas.bShots && (bAdditive ? LoadGlare () : LoadCorona ())) {n	int			bStencil, bDrawArrays, i;n	float			a1, a2;n	fVector		vCorona [4], vh [5], vPos, vNorm, vDir;n	tHitbox		*phb = gameData.models.hitboxes [objP->rType.polyObjInfo.nModel].hitboxes;n	float			fLength = X2F (phb->vMax [Z] - phb->vMin [Z]) / 2;n	float			dx = X2F (phb->vMax [X] - phb->vMin [X]);n	float			dy = X2F (phb->vMax [Y] - phb->vMin [Y]);n	float			fRad = (float) (sqrt (dx * dx + dy * dy) / 2);n	grsBitmap	*bmP;n	tRgbaColorf	color;nn	static fVector	vEye = fVector::ZERO;n	static tTexCoord2f	tcCorona [4] = {{{0,0}},{{1,0}},{{1,1}},{{0,1}}};nn	bmP = bAdditive ? bmpGlare : bmpCorona;n	colorP->alpha = alpha;n	vDir = objP->info.position.mOrient [FVEC].ToFloat();n	vPos = objP->info.position.vPos.ToFloat();n	vCorona [0] = vPos + vDir * (fScale * fLength);n	vh [4] = vCorona [0];n	vCorona [3] = vPos + vDir * (-fScale * fLength);n	G3TransformPoint (vPos, vPos, 0);n	G3TransformPoint (vCorona [0], vCorona [0], 0);n	G3TransformPoint (vCorona [3], vCorona [3], 0);n	vNorm = fVector::Normal(vPos, vCorona [0], vEye);n	fScale *= fRad;n	vCorona [0] += vNorm * fScale;n	vCorona [1] = vCorona [0] + vNorm * (-2 * fScale);n	vCorona [3] += vNorm * fScale;n	vCorona [2] = vCorona [3] + vNorm * (-2 * fScale);n	vNorm = fVector::Normal(vCorona [0], vCorona [1], vCorona [2]);n	vh [0] = vCorona [0] + vCorona [1] * 0.5f;n	vh [2] = vCorona [3] + vCorona [2] * 0.5f;n	vh [1] = vPos + vNorm * fScale;n	vh [3] = vPos + vNorm * (-fScale);n	for (i = 0; i < 4; i++)n		fVector::Normalize(vh [i]);n	a1 = (float) fabs (fVector::Dot(vh [2], vh [0]));n	a2 = (float) fabs (fVector::Dot(vh [3], vh [1]));n#if 0n	HUDMessage (0, "%1.2f %1.2f", a1, a2);n	glLineWidth (2);n	glColor4d (1,1,1,1);n	glDisable (GL_TEXTURE_2D);n	glBegin (GL_LINES);n	for (i = 1; i < 3; i++)n		glVertex3fv ((GLfloat *) (vh + i));n	glEnd ();n	glLineWidth (1);n	glColor4fv ((GLfloat *) colorP);n#endifn	if (bAdditive) {n		float fScale = coronaIntensities [gameOpts->render.coronas.nObjIntensity] / 2;n		color = *colorP;n		colorP = &color;n		color.red *= fScale;n		color.green *= fScale;n		color.blue *= fScale;n		}n	if (a2 < a1) {n		fix xSize = F2X (fScale);n		G3DrawSprite (objP->info.position.vPos, xSize, xSize, bmP, colorP, alpha, bAdditive, 1);n		}n	else {n		bStencil = StencilOff ();n		glDepthMask (0);n		glEnable (GL_TEXTURE_2D);n		glEnable (GL_BLEND);n		glColor4fv ((GLfloat *) colorP);n		if (OglBindBmTex (bmP, 1, -1))n			return;n		OglTexWrap (bmP->glTexture, GL_CLAMP);n		if (bAdditive)n			glBlendFunc (GL_ONE, GL_ONE);n		if ((bDrawArrays = G3EnableClientStates (1, 0, 0, GL_TEXTURE0))) {n			glTexCoordPointer (2, GL_FLOAT, 0, tcCorona);n			glVertexPointer (3, GL_FLOAT, sizeof (fVector), vCorona);n			glDrawArrays (GL_QUADS, 0, 4);n			G3DisableClientStates (1, 0, 0, -1);n			}n		else {n			glBegin (GL_QUADS);n			for (i = 0; i < 4; i++) {n				glTexCoord2fv ((GLfloat *) (tcCorona + i));n				glVertex3fv ((GLfloat *) (vCorona + i));n				}n			glEnd ();n			}n		if (bAdditive)n			glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);n#if 0n		glLineWidth (2);n		glColor4d (1,1,1,1);n		glDisable (GL_TEXTURE_2D);n		glBegin (GL_LINE_LOOP);n		for (i = 0; i < 4; i++)n			glVertex3fv ((GLfloat *) (vCorona + i));n		glEnd ();n		glLineWidth (1);n#endifn		glDepthMask (1);n		StencilOn (bStencil);n		}n	}n}nn// -----------------------------------------------------------------------------nnstatic inline float WeaponBlobSize (int nId)n{nif (nId == PHOENIX_ID)n	return 2.25f;nelse if (nId == PLASMA_ID)n	return 2.25f;nelse if (nId == HELIX_ID)n	return 1.25f;nelse if (nId == SPREADFIRE_ID)n	return 1.25f;nelse if (nId == OMEGA_ID)n	return 1.5f;nelse if (SMARTMSL_BLOB_ID)n	return 2.25f;nelse if (ROBOT_SMARTMSL_BLOB_ID)n	return 2.25f;nelse if (SMARTMINE_BLOB_ID)n	return 2.25f;nelse if (ROBOT_SMARTMINE_BLOB_ID)n	return 2.25f;nelsen	return 1.0f;n}nn// -----------------------------------------------------------------------------nnint RenderWeaponCorona (tObject *objP, tRgbaColorf *colorP, float alpha, fix xOffset,n								float fScale, int bSimple, int bViewerOffset, int bDepthSort)n{nif (!SHOW_OBJ_FX)n	return 0;n#if SHADOWSnif (SHOW_SHADOWS && (gameStates.render.nShadowPass != 1))n//	 (FAST_SHADOWS ? (gameStates.render.nShadowPass != 3) : (gameStates.render.nShadowPass != 1)))n	return 0;n#endifnif ((objP->info.nType == OBJ_WEAPON) && (objP->info.renderType == RT_POLYOBJ))n	RenderLaserCorona (objP, colorP, alpha, fScale);nelse if (gameOpts->render.coronas.bShots && LoadCorona ()) {n	int			bStencil;n	fix			xSize;n	tRgbaColorf	color;nn	static tTexCoord2f	tcCorona [4] = {{{0,0}},{{1,0}},{{1,1}},{{0,1}}};nn	vmsVector	vPos = objP->info.position.vPos;n	xSize = (fix) (WeaponBlobSize (objP->info.nId) * fScale * F1_0);n	bDepthSort = bDepthSort && bSimple && (gameOpts->render.bDepthSort > 0);n	if (xOffset) {n		if (bViewerOffset) {n			vmsVector o = gameData.render.mine.viewerEye - vPos;n			vmsVector::Normalize(o);n			vPos += o * xOffset;n			}n		elsen			vPos += objP->info.position.mOrient [FVEC] * xOffset;n		}n	if (xSize < F1_0)n		xSize = F1_0;n	color.alpha = alpha;n	alpha = coronaIntensities [gameOpts->render.coronas.nObjIntensity] / 2;n	color.red = colorP->red * alpha;n	color.green = colorP->green * alpha;n	color.blue = colorP->blue * alpha;n#if 0n	color.red *= color.red;n	color.green *= color.green;n	color.blue *= color.blue;n#endifn	if (bDepthSort)n		return TIAddSprite (bmpCorona, vPos, &color, xSize, xSize, 0, 1, 3);n	bStencil = StencilOff ();n	glDepthMask (0);n	glBlendFunc (GL_ONE, GL_ONE);n	if (bSimple) {n		G3DrawSprite (vPos, xSize, xSize, bmpCorona, &color, alpha, 1, 3);n		}n	else {n		fVector	quad [4], verts [8], vCenter, vNormal, v;n		float		dot;n		int		i, j;nn		glDisable (GL_CULL_FACE);n		glDepthFunc (GL_LEQUAL);n		glDepthMask (0);n		glEnable (GL_TEXTURE_2D);n		if (OglBindBmTex (bmpCorona, 1, -1))n			return 0;n		OglTexWrap (bmpCorona->glTexture, GL_CLAMP);n		G3StartInstanceMatrix (vPos, objP->info.position.mOrient);n		TransformHitboxf (objP, verts, 0);n		for (i = 0; i < 6; i++) {n			vCenter.SetZero();n			for (j = 0; j < 4; j++) {n				quad [j] = verts [hitboxFaceVerts [i][j]];n				vCenter += quad [j];n				}n			vCenter = vCenter * 0.25f;n			vNormal = fVector::Normal (quad [0], quad [1], quad [2]);n			v = vCenter; fVector::Normalize (v);n			dot = fVector::Dot (vNormal, v);n			if (dot >= 0)n				continue;n			glColor4f (colorP->red, colorP->green, colorP->blue, alpha * (float) sqrt (-dot));n			glBegin (GL_QUADS);n			for (j = 0; j < 4; j++) {n				v = quad [j] - vCenter;n				quad [j] += v * fScale;n 				glTexCoord2fv ((GLfloat *) (tcCorona + j));n				glVertex3fv ((GLfloat *) (quad + j));n				}n			glEnd ();n			}n		G3DoneInstance ();n		glDepthFunc (GL_LESS);n		glDisable (GL_TEXTURE_2D);n		glEnable (GL_CULL_FACE);n		}n	glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);n	glDepthMask (1);n	StencilOn (bStencil);n	}nreturn 0;n}nn// -----------------------------------------------------------------------------nn//extern vmsAngVec vmsAngVec::ZERO;nnvoid RenderShockwave (tObject *objP)n{nif (!SHOW_OBJ_FX)n	return;n#if SHADOWSnif (SHOW_SHADOWS && (gameStates.render.nShadowPass != 1))n//	 (FAST_SHADOWS ? (gameStates.render.nShadowPass != 3) : (gameStates.render.nShadowPass != 1)))n	return;n#endifnif ((objP->info.nType == OBJ_WEAPON) && gameData.objs.bIsWeapon [objP->info.nId]) {n		vmsVector	vPos;n		int			bStencil;nn	vPos = objP->info.position.vPos + objP->info.position.mOrient [FVEC] * (objP->info.xSize / 2);n	bStencil = StencilOff ();n	if (EGI_FLAG (bShockwaves, 1, 1, 0) &&n		 (objP->mType.physInfo.velocity [X] || objP->mType.physInfo.velocity [Y] || objP->mType.physInfo.velocity [Z])) {n			fVector			vPosf;n			int				h, i, j, k, n;n			float				r [4], l [4], alpha;n			tRgbaColorf		*pc = gameData.weapons.color + objP->info.nId;nn		G3StartInstanceMatrix (vPos, objP->info.position.mOrient);n		glDepthMask (0);n		glDisable (GL_TEXTURE_2D);n		//OglCullFace (1);n		glDisable (GL_CULL_FACE);n		r [3] = X2F (objP->info.xSize);n		if (r [3] >= 3.0f)n			r [3] /= 1.5f;n		else if (r [3] < 1)n			r [3] *= 2;n		else if (r [3] < 2)n			r [3] *= 1.5f;n		r [2] = r [3];n		r [1] = r [2] / 4.0f * 3.0f;n		r [0] = r [2] / 3;n		l [3] = (r [3] < 1.0f) ? 10.0f : 20.0f;n		l [2] = r [3] / 4;n		l [1] = -r [3] / 6;n		l [0] = -r [3] / 3;n		alpha = 0.15f;n		for (h = 0; h < 3; h++) {n			glBegin (GL_QUAD_STRIP);n			for (i = 0; i < RING_SIZE + 1; i++) {n				j = i % RING_SIZE;n				for (k = 0; k < 2; k++) {n					n = h + k;n					glColor4f (pc->red, pc->green, pc->blue, (n == 3) ? 0.0f : alpha);n					vPosf = vRing [j];n					vPosf [X] *= r [n];n					vPosf [Y] *= r [n];n					vPosf [Z] = -l [n];n					G3TransformPoint(vPosf, vPosf, 0);n					glVertex3fv ((GLfloat *) &vPosf);n					}n				}n			glEnd ();n			}n		glEnable (GL_CULL_FACE);n		for (h = 0; h < 3; h += 2) {n			glCullFace (h ? GL_FRONT : GL_BACK);n			glColor4f (pc->red, pc->green, pc->blue, h ? 0.1f : alpha);n			glBegin (GL_TRIANGLE_STRIP);n			for (j = 0; j < RING_SIZE; j++) {n				vPosf = vRing [nStripIdx [j]];n				vPosf [X] *= r [h];n				vPosf [Y] *= r [h];n				vPosf [Z] = -l [h];n				G3TransformPoint(vPosf, vPosf, 0);n				glVertex3fv ((GLfloat *) &vPosf);n				}n			glEnd ();n			}n		glDepthMask (1);n		OglCullFace (0);n		G3DoneInstance ();n		}n	StencilOn (bStencil);n	}n}nn// -----------------------------------------------------------------------------nn#define TRACER_WIDTH	3nnvoid RenderTracers (tObject *objP)n{nif (!SHOW_OBJ_FX)n	return;n#if SHADOWSnif (SHOW_SHADOWS && (gameStates.render.nShadowPass != 1))n//	 (FAST_SHADOWS ? (gameStates.render.nShadowPass != 3) : (gameStates.render.nShadowPass != 1)))n	return;n#endifnif (EGI_FLAG (bTracers, 0, 1, 0) &&n	 (objP->info.nType == OBJ_WEAPON) && ((objP->info.nId == VULCAN_ID) || (objP->info.nId == GAUSS_ID)n	 /*&& !gameData.objs.nTracers [objP->cType.laserInfo.parent.nObject]*/)) {n#if 0n	objP->rType.polyObjInfo.nModel = gameData.weapons.info [SUPERLASER_ID + 1].nModel;n	objP->info.xSize = FixDiv (gameData.models.polyModels [objP->rType.polyObjInfo.nModel].rad,n								gameData.weapons.info [objP->info.nId].po_len_to_width_ratio) / 4;n	gameData.models.nScale = F1_0 / 4;n	DrawPolygonObject (objP, 0);n	gameData.models.nScale = 0;n#elsen		fVector			vPosf [2], vDirf;n		short				i;n		int				bStencil;n//		static short	patterns [] = {0x0603, 0x0203, 0x0103, 0x0202};nn	vPosf [0] = objP->info.position.vPos.ToFloat();n	vPosf [1] = objP->info.vLastPos.ToFloat();n	G3TransformPoint (vPosf [0], vPosf [0], 0);n	G3TransformPoint (vPosf [1], vPosf [1], 0);n	vDirf = vPosf [0] - vPosf [1];n	if (vDirf.IsZero()) {n		//return;n		vPosf [1] = OBJECTS [objP->cType.laserInfo.parent.nObject].info.position.vPos.ToFloat();n		G3TransformPoint(vPosf [1], vPosf [1], 0);n		vDirf = vPosf [0] - vPosf [1];n		if(vDirf.IsZero())n			return;n		}n	bStencil = StencilOff ();n	glDepthMask (0);n	glEnable (GL_LINE_STIPPLE);n	glEnable (GL_BLEND);n	glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);n	glEnable (GL_LINE_SMOOTH);n	glLineStipple (6, 0x003F); //patterns [h]);n	vDirf *= TRACER_WIDTH / 20.0f;n/*n	vDirf [Y] *= TRACER_WIDTH / 20.0f;n	vDirf [Z] *= TRACER_WIDTH / 20.0f;n*/n	for (i = 1; i < 5; i++) {n		glLineWidth ((GLfloat) (TRACER_WIDTH * i));n		glBegin (GL_LINES);n		glColor4d (1, 1, 1, 0.5 / i);n		glVertex3fv ((GLfloat *) (vPosf + 1));n		glVertex3fv ((GLfloat *) vPosf);n#if 0n		VmVecDec (vPosf, &vDirf);n		VmVecDec (vPosf + 1, &vDirf);n#endifn		glEnd ();n		}n	glLineWidth (1);n	glDisable (GL_LINE_STIPPLE);n	glDisable (GL_LINE_SMOOTH);n	glDepthMask (1);n	StencilOn (bStencil);n#endifn	}n}nn// -----------------------------------------------------------------------------n// Draws a texture-mapped laser boltn#if 0nvoid Laser_draw_one (int nObject, grsBitmap * bmp)n{n	int t1, t2, t3;n	g3sPoint p1, p2;n	tObject *objP = OBJECTS + nObject;n	vmsVector start_pos,vEndPos;n	fix Laser_length = gameData.models.polyModels [objP->rType.polyObjInfo.nModel].rad * 2;n	fix Laser_width = Laser_length / 8;nn	start_pos = objP->info.position.vPos;n	VmVecScaleAdd (&vEndPos,&start_pos,&objP->info.position.mOrient [FVEC],-Laser_length);nn	G3TransformAndEncodePoint (&p1,&start_pos);n	G3TransformAndEncodePoint (&p2,&vEndPos);nn	t1 = gameStates.render.nLighting;n	t2 = gameStates.render.nInterpolationMethod;n	t3 = gameStates.render.bTransparency;nn	gameStates.render.nLighting  = 0;n	//gameStates.render.nInterpolationMethod = 3;	 //Full perspectiven	gameStates.render.nInterpolationMethod = 1;	//Linearn	gameStates.render.bTransparency = 1;n#if 0n	GrSetColor (gr_getcolor (31,15,0);n	g3_draw_line_ptrs (p1,p2);n	g3_draw_rod (p1,0x2000,p2,0x2000);n	g3_draw_rod (p1,Laser_width,p2,Laser_width);n#elsen	G3DrawRodTexPoly (bmp,&p2,Laser_width,&p1,Laser_width,0,NULL);n#endifn	gameStates.render.nLighting = t1;n	gameStates.render.nInterpolationMethod = t2;n	gameStates.render.bTransparency = t3;n}n#endifnn// -----------------------------------------------------------------------------nn#if 0nstatic fVector vTrailOffs [2][4] = {{{{0,0,0}},{{0,-10,-5}},{{0,-10,-50}},{{0,0,-50}}},n												{{{0,0,0}},{{0,10,-5}},{{0,10,-50}},{{0,0,-50}}}};n#endifnnvoid RenderLightTrail (tObject *objP)n{n	tRgbaColorf		color, *colorP;n	int				nTrailItem = -1, nCoronaItem = -1, bGatling = 0, bAdditive = 1; //gameOpts->render.coronas.bAdditiveObjs;nnif (!SHOW_OBJ_FX)n	return;nif (!gameData.objs.bIsWeapon [objP->info.nId])n	return;n#if SHADOWSnif (SHOW_SHADOWS && (gameStates.render.nShadowPass != 1))n//	 (FAST_SHADOWS ? (gameStates.render.nShadowPass != 3) : (gameStates.render.nShadowPass != 1)))n	return;n#endifnbGatling = (objP->info.nId == VULCAN_ID) || (objP->info.nId == GAUSS_ID);nif (objP->info.renderType == RT_POLYOBJ)n	colorP = gameData.weapons.color + objP->info.nId;nelse {n	tRgbColorb	*pcb = VClipColor (objP);n	color.red = pcb->red / 255.0f;n	color.green = pcb->green / 255.0f;n	color.blue = pcb->blue / 255.0f;n	colorP = &color;n	}nnif (!gameData.objs.bIsSlowWeapon [objP->info.nId] && gameStates.app.bHaveExtraGameInfo [IsMultiGame] && EGI_FLAG (bLightTrails, 0, 0, 0)) {n	if (gameOpts->render.smoke.bPlasmaTrails)n		;//DoObjectSmoke (objP);n	else if (EGI_FLAG (bLightTrails, 1, 1, 0) && (objP->info.nType == OBJ_WEAPON) &&n				!gameData.objs.bIsSlowWeapon [objP->info.nId] &&n				(objP->mType.physInfo.velocity [X] || objP->mType.physInfo.velocity [Y] || objP->mType.physInfo.velocity [Z]) &&n				(bAdditive ? LoadGlare () : LoadCorona ())) {n			fVector			vNormf, vOffsf, vTrailVerts [4];n			int				i, bStencil, bDrawArrays, bDepthSort = (gameOpts->render.bDepthSort > 0);n			float				l, r, dx, dy;n			grsBitmap		*bmP;nn			static fVector vEye = fVector::ZERO;nn			static tRgbaColorf	trailColor = {0,0,0,0.33f};n			static tTexCoord2f	tTexCoordTrail [4] = {{{0,0}},{{1,0}},{{1,1}},{{0,1}}};nn		if (objP->info.renderType == RT_POLYOBJ) {n			tHitbox	*phb = gameData.models.hitboxes [objP->rType.polyObjInfo.nModel].hitboxes;n			l = X2F (phb->vMax [Z] - phb->vMin [Z]);n			dx = X2F (phb->vMax [X] - phb->vMin [X]);n			dy = X2F (phb->vMax [Y] - phb->vMin [Y]);n			r = (float) (sqrt (dx * dx + dy * dy) / sqrt (2.0f));n			if (objP->info.nId == FUSION_ID) {n				l *= 1.5f;n				r /= 1.5f;n				}n			}n		else {n			r = WeaponBlobSize (objP->info.nId) / 1.5f;n			l = 4 * r;n			}n		bmP = bAdditive ? bmpGlare : bmpCorona;n		memcpy (&trailColor, colorP, 3 * sizeof (float));n		if (bAdditive) {n			float fScale = coronaIntensities [gameOpts->render.coronas.nObjIntensity] / 2;n			trailColor.red *= fScale;n			trailColor.green *= fScale;n			trailColor.blue *= fScale;n			}n#if 0n		vmsVector vOffs = objP->info.position.vPos + objP->info.position.mOrient [FVEC] * (F1_0 / 4);n		CreateLightTrail (vOffs, objP->info.position.mOrient [FVEC], l, 100.0f, bmP, &trailColor, true);n		if (bDepthSort)n			return;n#elsen		vOffsf = objP->info.position.mOrient [FVEC].ToFloat();n		vTrailVerts [0] = objP->info.position.vPos.ToFloat();n		vTrailVerts [0] += vOffsf * l;n		vTrailVerts [2] = vTrailVerts [0] - vOffsf * 100;n		G3TransformPoint (vTrailVerts [0], vTrailVerts [0], 0);n		G3TransformPoint (vTrailVerts [2], vTrailVerts [2], 0);n		vOffsf = vTrailVerts [2] - vTrailVerts [0];n		vOffsf = vOffsf * (r * 0.04f);n		vNormf = fVector::Normal (vTrailVerts [0], vTrailVerts [2], vEye);n		vNormf = vNormf * (r * 4);n		vTrailVerts [1] = vTrailVerts [0] + vNormf;n		vTrailVerts [1] += vOffsf;n		vTrailVerts [3] = vTrailVerts [0] - vNormf;n		vTrailVerts [3] += vOffsf;n		if (bDepthSort) {n			nTrailItem = TIAddPoly (NULL, NULL, bmP, vTrailVerts, 4, tTexCoordTrail, &trailColor, NULL, 1, 0, GL_QUADS, GL_CLAMP, bAdditive, -1);n			}n		else {n			glEnable (GL_BLEND);n			if (bAdditive)n				glBlendFunc (GL_ONE, GL_ONE);n			elsen				glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);n			glColor4fv ((GLfloat *) &trailColor);n			bDrawArrays = G3EnableClientStates (1, 0, 0, GL_TEXTURE0);n			bStencil = StencilOff ();n			glDisable (GL_CULL_FACE);n			glDepthMask (0);n			glEnable (GL_TEXTURE_2D);n			if (OglBindBmTex (bmP, 1, -1))n				return;n			OglTexWrap (bmP->glTexture, GL_CLAMP);n			if (bDrawArrays) {n				glTexCoordPointer (2, GL_FLOAT, 0, tTexCoordTrail);n				glVertexPointer (3, GL_FLOAT, sizeof (fVector), vTrailVerts);n				glDrawArrays (GL_QUADS, 0, 4);n				G3DisableClientStates (1, 0, 0, -1);n				}n			else {n				glBegin (GL_QUADS);n				for (i = 0; i < 4; i++) {n					glTexCoord3fv ((GLfloat *) (tTexCoordTrail + i));n					glVertex3fv ((GLfloat *) (vTrailVerts + i));n					}n				glEnd ();n			if (bAdditive)n				glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);n#if 0 // render outlinen				glDisable (GL_TEXTURE_2D);n				glColor3d (1, 0, 0);n				glBegin (GL_LINE_LOOP);n				for (i = 0; i < 4; i++)n					glVertex3fv ((GLfloat *) (vTrailVerts + i));n				glEnd ();n#endifn				}n			StencilOn (bStencil);n			glEnable (GL_CULL_FACE);n			glDepthMask (1);n			}n#endifn		}n	RenderShockwave (objP);n	}nif ((objP->info.renderType != RT_POLYOBJ) || (objP->info.nId == FUSION_ID))n	RenderWeaponCorona (objP, colorP, 0.5f, 0, 2.0f + X2F (d_rand() % (F1_0 / 8)), 1, 0, 1);nelsen	RenderWeaponCorona (objP, colorP, 0.75f, 0, bGatling ? 1.0f : 2.0f, 0, 0, 0);n}nn// -----------------------------------------------------------------------------nnvoid DrawDebrisCorona (tObject *objP)n{n	static	tRgbaColorf	debrisGlow = {0.66f, 0, 0, 1};n	static	tRgbaColorf	markerGlow = {0, 0.66f, 0, 1};n	static	time_t t0 = 0;nnif (objP->info.nType == OBJ_MARKER)n	RenderWeaponCorona (objP, &markerGlow, 0.75f, 0, 4, 1, 1, 0);n#if DBGnelse if (objP->info.nType == OBJ_DEBRIS) {n#elsenelse if ((objP->info.nType == OBJ_DEBRIS) && gameOpts->render.nDebrisLife) {n#endifn	float	h = (float) nDebrisLife [gameOpts->render.nDebrisLife] - X2F (objP->info.xLifeLeft);n	if (h < 0)n		h = 0;n	if (h < 10) {n		h = (10 - h) / 20.0f;n		if (gameStates.app.nSDLTicks - t0 > 50) {n			t0 = gameStates.app.nSDLTicks;n			debrisGlow.red = 0.5f + X2F (d_rand () % (F1_0 / 4));n			debrisGlow.green = X2F (d_rand () % (F1_0 / 4));n			}n		RenderWeaponCorona (objP, &debrisGlow, h, 5 * objP->info.xSize, 1.5f, 1, 1, 0);n		}n	}n}nn//------------------------------------------------------------------------------nnfix flashDist=F2X (.9);nn//create flash for tPlayer appearancenvoid CreatePlayerAppearanceEffect (tObject *playerObjP)n{n	vmsVector	pos;n	tObject		*effectObjP;nnif (playerObjP == gameData.objs.viewerP)n	pos = playerObjP->info.position.vPos + playerObjP->info.position.mOrient [FVEC] * FixMul(playerObjP->info.xSize,flashDist);nelsen	pos = playerObjP->info.position.vPos;neffectObjP = ObjectCreateExplosion (playerObjP->info.nSegment, &pos, playerObjP->info.xSize, VCLIP_PLAYER_APPEARANCE);nif (effectObjP) {n	effectObjP->info.position.mOrient = playerObjP->info.position.mOrient;n	if (gameData.eff.vClips [0][VCLIP_PLAYER_APPEARANCE].nSound > -1)n		DigiLinkSoundToObject (gameData.eff.vClips [0][VCLIP_PLAYER_APPEARANCE].nSound, OBJ_IDX (effectObjP), 0, F1_0, SOUNDCLASS_PLAYER);n	}n}nn//------------------------------------------------------------------------------n//eofn